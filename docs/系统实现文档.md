# 系统实现报告

## 一、实现环境

### 1.前端技术栈

- Vue————3.2.36
- axios————1.2.0 
- Vuex————4.0.2
- Vue-Router————4.1.6
- Naive-UI
- Element-UI
- Echarts

### 2.后端技术栈

- MySQL

### 3.Github

[alonelysnake/BUAA-Database-Vue-Frontend: 数据库大作业Vue前端 (github.com)](https://github.com/alonelysnake/BUAA-Database-Vue-Frontend)

## 二、系统功能结构图

- 用户功能模块

![](./img\用户功能模块.png)

- 管理员功能模块 

## 三、数据库基本表定义及约束

基本表的定义，主外码等完整性约束定义，索引的定义

## 四、系统安全性设计

### 1.前端展示

#### 控制用户访问权限

- 用户不能修改其他用户的个人信息
- 用户不能查看或修改其他用户的订单信息
- 用户不能修改其他用户的商品信息
- 用户不能查看或修改其他用户的收藏列表

#### Vue路由全局守卫

当用户进行需要鉴别用户的操作时，使用全局路由前置守卫(beforeEach)将页面跳转到登陆页面，防止产生非法用户购买、发布商品等情况发生。

```js
router.beforeEach((to, from, next) => {
    // 目标页面要求用户登陆
    if (to.meta.requiresLoggedIn && !store.state.loggedIn) {
        next({
            path: '/logReg/login',
            query: {
                redirect: to.path
            }
        })
    } else {
        next()
    }
})
```

#### md5码加密存储

如果直接将密码信息以明码方式保存在数据库中，不使用任何保密措施，系统管理员就很容易能得到原来的密码信息，这些信息一旦泄露， 密码也很容易被破译。为了增加安全性，有必要对数据库中需要保密的信息进行加密。

MD5算法可以很好地解决这个问题，因为它可以将任意长度的输入串经过计算得到固定长度的输出，而且只有在明文相同的情况下，才能等到相同的密文。并且这个算法是不可逆的，即便得到了加密以后的密文，也不可能通过解密算法反算出明文。可以把用户的密码以MD5值的方式保存起来，用户注册的时候，系统是把用户输入的密码计算成 MD5 值，然后再去和数据库保存的 MD5 值进行比较。只有密文相同，系统才能通过用户登陆请求。

通过这样的步骤，系统在并不知道用户密码明码的情况下就可以确定用户登录系统的合法性。这样不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。

```js
let post = {
    'email': mail.value,
	// 将用户密码转换为md5码，再传输到后端判断
    'password': md5(password.value),
};
request.post("/login/", JSON.stringify(post))
```

对用户密码使用md5码加密存储，防止密码数据在传输

#### 密码格式验证

为防止用户密码过短、过于简单而导致密码被暴力破解，我们规定密码长度在6-15位之间，并且要求字母和数字结合。在用户注册或修改密码时，对用户输入的密码利用正则表达式进行格式验证，如果不符合系统规定则提示用户重新设置密码。

```js
let format = /^(?=.*[a-zA-Z])(?=.*[0-9])[a-zA-Z0-9~!@&%#_]{6,15}$/gi
if(!format.test(model.newPassword)){
    message.error('密码长度应在6-15位，且同时包含字母与数字')
    return;
}
```

### 2.后端控制



## 五、SQL代码说明

### 1.存储过程

### 2.触发器

### 3.函数

## 六、主要技术和模块

### 1.后端映射数据库实体

### 2.后端设计模式

### 3.前端单页面路由

为实现单页面应用，使用Vue-Router来管理路由以及该路由下挂载的组件。在router/index.js下，设置了所有路由和组件的对应关系。路由发生切换时，只销毁并挂载发生变化的组件，未变化的组件保持不变，最大化的减少了前端重复挂载的开销以及由此产生的对后端数据库的不必要请求。

### 4.前端组件动态渲染

用户对页面的操作和前后端异步执行时导致的数据动态变化需要保证组件能随数据的变化而呈现不同的展示。本项目通过ref()函数实现了组件与数据的动态绑定，从而根据数据变化渲染出不同的结果。所有变量都用ref包裹成一个对象后绑定到html组件上，通过修改其中的value属性改变具体值。不论是用户在页面中的操作还是代码执行阶段的赋值，都是在对同一片空间进行修改，由此实现了前端的数据协同。

### 5.前后端数据通信

前端部分中，在utils/request.js中定义并暴露了一个对象request。该对象拥有post和get方法，用于向后端发送和接收数据。进行通信时，前端首先设置好两个参数：要调用函数的路由、按照json格式的字符串化的数据。然后调用request对象的方法向后端发出请求。考虑到后端的处理延迟，我们采用异步的方法进行通信。后端处理完成返回结果时，在then()函数中用箭头函数来接收必须同步执行的指令。对于其他不必与这个请求同步的指令，前端发出请求后可以继续顺序执行，不必等待。

后端会以路由的形式暴露出一系列的接口函数。前端调用的接口函数会尝试接收并解析前端发送的参数，进行处理后再按照json格式返回。因为所有参数都是键值对的形式，所以只要前后端设置了相同的key，就可以得到期望数据。示例如下：

```javascript
let post = JSON.stringify({
	'username': name.value,
	'email': mail.value,
	'password': md5(password.value),
});
request.post("register/", post).then(res => {
    //后端的返回结果
    let recvMessage=res.message;//接受后端返回信息
    let success = recvMessage==='注册成功';
    if (success) {
        message.success('注册成功');
    } else {
        message.error(recvMessage);
    }
});
```

对应的后端部分代码：

```python
def register(request):
    content = request.body.decode()
    content_dict = json.loads(content)
    name = content_dict.get('username')
    email = content_dict.get('email')
    password = content_dict.get('password')
    ...
    data = {'message':message}
    result = JsonResponse(dict(data))
    return result
```

## 七、系统功能演示

## 八、源程序简要说明

### 1.代码结构说明

#### 前端

前端以src文件夹为根目录，结构及部分文件如下所示：

- components。组成页面的各个组件。
  - Login.vue。登录组件。展示登录时的输入框以及调用函数等。
  - Register.vue。注册组件。展示注册时的输入框以及调用函数等。
  - Header.vue。顶部导航栏组件。用于各个界面的导航跳转。
  - ……
- router。只有`index.js`一个文件，作为路由文件。
- static。页面的背景图等资源文件。
- store。只有`index.js`一个文件，作为储存全局变量的文件。
- utils。
  - local.js。实现浏览器缓存的配置文件。
  - request.js。前后端交互的配置文件。
- view。导航栏下的主体页面，根据导航栏的选择进行跳转。
  - DetailPage.vue。游戏详情页。
  - FilterPage。按优惠筛选页。
  - HeatPage。游戏热度页。
  - Home。主页。
  - RegisterLoginPage。登陆注册页。
  - User。用户信息页。

#### 后端

后端的根目录为back文件夹。结构如下：

- backend。
  - migrations。
  - models.py。包含所有实体类。
  - urls.py。包含所有暴露给前端的接口函数。
- mysite。

### 2.运行流程示例

以登录为例，展示程序的运行流程。

1. 用户输入邮箱和密码后点击登录按钮。
2. 前端得到用户输入的两个字段，调用`handleLogin()`方法，将密码加密后向后端发出请求，调用后端的`login()`函数。
3. 后端接收前端传递的邮箱和密码，判断数据库中邮箱是否存在以及密码是否正确。如果正确，返回登录成功的消息，以及用户的部分个人信息。如果错误，返回错误原因。
4. 前端接收后端返回的结果。如果结果为“登录成功”，则设置用户相关的全局量，然后跳转到首页。如果登录失败，则输出登录失败的原因。

前端代码：

```javascript
handleLogin() {
        loading.value = true;
        let post = {
          'email': mail.value,
          'password': md5(password.value),
        };
        request.post("/login/", JSON.stringify(post)).then(res => {
          let recvMessage = res.message;
          let userInfo = res.info;
          let success = !(userInfo.id === undefined);
          if (success) {
            message.success("登录成功");
            // 用户全局量赋值
            store.state.user.nickname = userInfo.username;
            store.state.user.userID = userInfo.id;
            store.state.user.sales = userInfo.sales;
            store.state.user.avatar = userInfo.photo;
            store.state.user.email = userInfo.email;
            store.state.user.intro = userInfo.profile;
            store.state.user.sex = userInfo.gender;
            store.state.user.like = userInfo.likes;
            store.state.user.dislike = userInfo.dislikes;
            store.state.loggedIn = true;

            router.push({name: "Home"});
          } else {
            // 登录失败提示
            message.error(recvMessage);
          }
          loading.value = false;
        });
      },
```

后端代码：

```javascript
def login(request):
    content = request.body.decode()
    content_dict = json.loads(content)
    print(content_dict)
    email = content_dict.get('email')
    password = content_dict.get('password')
    info = {}
    if User.objects.filter(email=email).exists():
        user = User.objects.get(email=email)
        if user.password == password:
            message = "登录成功"
            info = user.to_dict()
        else:
            message = "密码错误，请重新输入密码"
    else:
        message = "该用户不存在，请先检查邮箱是否正确"
    data = {'message': message, "info": info}
    result = JsonResponse(dict(data))
    return result
```

## 九、亮点介绍

### 1.使用缓存机制

- 使用**Session机制**让用户无需重复登陆。在页面加载时读取sessionStorage里的状态信息，在页面刷新时将Vuex里的信息保存到sessionStorage里。

  ```js
  onBeforeMount(()=>{
      if (sessionStorage.getItem("store")) {
          store.replaceState(Object.assign({}, store.state, JSON.parse(sessionStorage.getItem("store"))))
      }
  
      window.addEventListener("beforeunload", () => {
          sessionStorage.setItem("store", JSON.stringify(store.state))
      })
  })
  ```

- 使用**Storage机制**保存用户的历史搜索记录。在用户搜索游戏后，将游戏id和游戏名称存入localStorage。当用户再次点击搜索框时，将读取localStorage中的信息，并将游戏名展示出来。

  ![image-20221223181108339](./img/搜索框.png)

  ```js
  const LOCAL_STORAGE_KEY = "searchHistory";
  
  class Local { }
  // 用户点击搜索后调用，存储历史记录
  Local.saveHistory = (arr) => {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(arr));
  }
  // 用户点击搜索框调用，读取历史记录
  Local.loadHistory = () =>JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY))
  
  // 清空历史记录
  Local.removeAllHistory=()=>{
      localStorage.removeItem(LOCAL_STORAGE_KEY)
  }
  
  module.exports = Local
  ```

### 2.数据管理功能

通过设计Django的管理员端，系统可以支持通过Excel文件导入。（zl补充一下）

### 3.数据展示

我们使用多种形式展示数据，首页通过轮播图为用户提供当前人气较大的游戏。对于用户上架的商品、订单等信息，则通过文字和图片相结合的形式在表中展示，并且支持用户进行搜索、排序、翻页、筛选、管理等操作。

我们实现了通过**模糊搜索**查找用户所需数据，支持对数据的全文检索。同时在热门游戏页面中，支持用户**选择多个游戏进行比较**，比较这些游戏发售以来的在线人数变化情况，帮助用户更好地掌握不同游戏的人气变化趋势和相互之间的影响。同时，我们通过折线图的形式，支持用户查看游戏发售以来价格变化趋势，通过对比帮助用户更好地预测游戏的折扣情况。

### 4.业务功能覆盖

通过上述功能展示，我们基本保证了平台基础功能的完整性。对现有的平台进行了一定程度上功能补充，满足用户的对比游戏热度、查询游戏价格波动、游戏产品交易等基本需求。对于用户而言在当下这个数据爆炸、平台价格不透明的环境下，用户能够方便快捷地获取到游戏信息，并且可以可视化对比，更包含收藏、排行等人性化功能，这对用户的使用体验将会有很大提升和改善。

用户能够**管理**自己已上架的商品，进行批量删除、修改等操作，能够修改或删除与自己相关的订单。

### 5.统计分析

用户可以按自己的偏好，按游戏的不同特性设置多个条件进行筛选，即进行**数据钻取**。对于游戏的价格数据，我们使用Echarts包辅助生成折线图进行数据展示。用户可以将光标放到折线图的每个点上查看该点的详细信息。折线图也支持用户**多粒度**地对数据进行统计分析。用户可以选择查看所有时间段的信息，也可以筛选查看一周内、一个月内、一年内的统计信息，能更好的满足用户的需求。对于展示出的数据折线图，用户可以保存至本地进行分析。

### 6.安全防护

我们提供了用户注册登陆功能，用于鉴别用户的访问权限。同时通过Django设置管理员端的功能，管理员能够导入或修改系统数据，对用户产生的数据，如评论、商品、订单进行审核，以防用户恶意评论、刷单等情况发生。

系统将记录和获取用户对数据的操作日志，管理人员能够对对日志进行浏览、查询和统计分析。对于网站的管理人员来讲，其可以方便地使用管理员模式对于用户数据、游戏信息、用户操作信息进行分析、操作。并且可以将数据以 PDF 格式进行导出，方便了平台管理。(zl修改一下)

对于用户密码这类重要数据，为防止其泄露后严重危害用户账户安全，我们没有在数据库内明文存储，而是通过将原数据转换为md5码后再存入数据库中。同时，为避免用户密码被暴力破解，系统将对用户设置的密码进行格式验证，要求密码长度不能过短，并且不能为纯数字。

## 十、收获与体会

## 十一、小组成员分工

|              | 王永瑶                                                       | 李京昊                                                       | 卓乐                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 系统设计阶段 | 1. 前期调研、分析系统需求设计<br>2. 数据库系统的概念模式（E-R图）<br>3. 设计数据库关系模式<br>4.根据需求设计前端网页基本布局与模块 | 1. 前期调研、分析系统需求设计<br/>2. 数据库系统的概念模式（E-R图）<br/>3. 编写数据流图与数据元素表<br />4. 根据需求设计前端网页基本布局与模块 | 1. 前期调研、分析系统需求设计<br/>2. 数据库系统的概念模式（E-R图）<br/>3.设计数据库系统的逻辑模式并将所有关系规范化到 3NF<br>4.设计后端架构与数据库的主要功能 |
| 系统实现阶段 |                                                              |                                                              |                                                              |
| 系统报告撰写 |                                                              |                                                              |                                                              |

